package numberofislands_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNumberOfIslands(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		grid [][]byte
		want int
	}{
		{
			name: "1 island",
			grid: [][]byte{
				{'1', '1', '1', '1', '0'},
				{'1', '1', '0', '1', '0'},
				{'1', '1', '0', '0', '0'},
				{'0', '0', '0', '0', '0'},
			},
			want: 1,
		},
		{
			name: "2 islands",
			grid: [][]byte{
				{'0', '0', '1', '0', '1'},
				{'0', '0', '1', '0', '1'},
				{'1', '1', '1', '0', '1'},
				{'0', '0', '0', '0', '1'},
			},
			want: 2,
		},
		{
			name: "3 islands",
			grid: [][]byte{
				{'1', '1', '0', '0', '0'},
				{'1', '1', '0', '0', '0'},
				{'0', '0', '1', '0', '0'},
				{'0', '0', '0', '1', '1'},
			},
			want: 3,
		},
		{
			name: "58 islands",
			grid: [][]byte{
				{'1', '0', '0', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
				{'1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '0', '1', '0'},
				{'0', '0', '0', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', '0', '1', '0', '1', '0'},
				{'0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '1'},
				{'0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
				{'1', '0', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '1', '0', '1'},
				{'0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1'},
				{'0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '0', '1', '0', '1', '1', '0', '1', '1', '1', '0'},
				{'0', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1'},
				{'0', '0', '1', '0', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '0', '0', '1', '0'},
				{'1', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '1', '0', '1', '0'},
				{'0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '1', '1', '1', '0', '1', '1', '0', '0'},
				{'1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1'},
				{'0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '1', '0', '0', '0'},
				{'0', '0', '1', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0'},
				{'1', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1'},
				{'1', '0', '1', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0'},
				{'0', '1', '1', '0', '0', '0', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '0', '0'},
				{'0', '1', '0', '0', '0', '0', '1', '1', '0', '0', '1', '0', '1', '0', '0', '1', '0', '0', '1', '1'},
				{'0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', '0'},
			},
			want: 58,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			assert.Equal(t, tt.want, numIslands(tt.grid))
		})
	}
}

// Time O(N*M)
// where M and N are rows and columns,
// We need to visit each cell in a grid
//
// Space O(min(M, N))
// We need to queue and deque elements from time to time.
// the max size of the queue can be min(n,m).
func numIslands(grid [][]byte) int {
	rows, cols, islandsCount := len(grid), len(grid[0]), 0

	for i := range rows {
		for j := range cols {
			if grid[i][j] == '1' {
				breadthFirstSearch(grid, i, j)

				islandsCount++
			}
		}
	}

	return islandsCount
}

func breadthFirstSearch(grid [][]byte, startCoordinateX, startCoordinateY int) {
	queue := [][2]int{{startCoordinateX, startCoordinateY}}
	directions := [4][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}

	for len(queue) > 0 {
		startCoordinateX, startCoordinateY, queue = queue[0][0], queue[0][1], queue[1:]

		for _, direction := range directions {
			x, y := startCoordinateX+direction[0], startCoordinateY+direction[1]
			if x >= 0 && y >= 0 && len(grid) > x && len(grid[0]) > y && grid[x][y] == '1' {
				queue = append(queue, [2]int{x, y})
				grid[x][y] = '2'
			}
		}
	}
}
